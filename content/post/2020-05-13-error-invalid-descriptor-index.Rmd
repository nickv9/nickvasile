---
title: 'Debugging the Invalid Descriptor Index Error' 
author: Nick Vasile
date: '2020-05-13'
slug: error-invalid-descriptor-index
categories: []
tags: []
---

**This post is a work in progress**

# Motivation

I use the dbplyr, dplyr, DBI and odbc R packages to extract data held in Microsoft SQL on a daily basis. 

I used to run into the, "Invalid Descriptor Index," error documented [here](https://github.com/r-dbi/odbc/issues/309) constantly. It was awful! I spent so much time trying to find the, "problem," columns in tables that often had over 100 columns. The time I spent trying to get my queries to work severely reduced the time I had available to clean, transform and analyze my data.

Through the work of many great people sharing their expertise on GitHub, I was able to identify [a workaround that worked well for me](https://github.com/r-dbi/odbc/issues/309#issuecomment-615255613).

The workaround helped *me* continue my daily work but did nothing to *prevent* *others* from encountering the same issue in the future. One of the great things about R is the community and I would like to do my part to help. That might involve making a code change in a package or in another component involved.

I don't yet have a firm grasp on what, from a technical standpoint, leads to the failure but I do know many things are involved - specifically multiple R packages, ODBC drivers and Microsoft SQL Server.

I am comfortable as an R user and debugging C++ code individually but have not spent much time debugging multi-component issues in R. 

This investigation is an opportunity for me:

* Advance my R debugging skills so I well-armed to tackle other multi-component R issues in the future
* Understand, at a deep level, the root cause, and contributing factors, of the failure that leads to this error. With that understanding I will be a much better position to propose, evaluate and contribute to solutions.

# Scope

I'll be reproducing this issue using Microsoft SQL Server Express which is a free download available [here](https://www.microsoft.com/en-us/sql-server/sql-server-downloads).

I'll be focusing my analysis on when this error occurs running R on the Microsoft Windows operating system.

# Debugging the error

One of the primary motivations for this post is to force me to advance my debugging skills.

I decided to start with [the debugging chapter from Hadley Wickham's Advanced R book](https://adv-r.hadley.nz/debugging.html).

## Debugging Step 1: Google it!

I started out by Googling a portion of the error string, "`[Microsoft][ODBC SQL Server Driver]Invalid Descriptor Index`," which yielded quite a few relevant hits, including a surprising amount of duplicate GitHub issues raised in the odbc project.

Based on Hadley's recommendation in the book I decided to check out the [errorist package](https://github.com/r-assist/errorist) which gave me much more target hits because it included the entire text of the error message in the search string. It was also automatic, saving me a second or two of copying and pasting. I'll be incorporating this package into my debugging work-flow going forward!

Here is what I gleaned:

1. Judging by the sheer frequency, and recency, of this issue being reported, I don't believe this is a corner case affecting a small minority of R users. I've captured a list of relevant issues, and the Stack Overflow thread I found most helpful in [Appendix: Some Reports of, and references to, this issue](#issues).

2. This is  caused by a ODBC (the Microsoft C interface - not the R odbc package) constraint:

   + Called out as a limitation of `SQLGetData()` citing this portion of the documentation:

> There are several restrictions on using SQLGetData. Generally, columns accessed with SQLGetData:  
...  
Must have a higher column number than the last bound column. For example, if the last bound column is column 3, it is an error to call SQLGetData for column 2. For this reason, applications should make sure to place long data columns at the end of the select list.

SOURCE: [Microsoft documentation on "Getting Long Data"](https://docs.microsoft.com/en-us/sql/odbc/reference/develop-app/getting-long-data?view=sql-server-ver15)

3. The most common workaround is to put "long" columns at the end of the select 
statement, and there are a few different methods to do this. 
See [Appendix: Methods to move "long" data to end of query](#move_long_data) for
options to do this.

4. People have reported that the error doesn't occur with: 
    + RStudio's professional drivers which are part of their commercial 
    (you need to pay for) offerings. SOURCE: [GitHub issue comment from Jim Hester](https://github.com/r-dbi/odbc/issues/86#issuecomment-558280484)
    + RODBC package. 
    [Reported in this GitHub issue](https://github.com/r-dbi/odbc/issues/256#issue-411385255),
    although Jim Hester reported [here](https://github.com/r-dbi/odbc/issues/86#issuecomment-558199954)
    that RODBC is simply truncating the long data.
    + FreeTDS drivers SOURCE: [Bill Evans comment on GitHub](https://github.com/r-dbi/DBI/issues/315#issuecomment-639984938) See [Appendix: Installing and using the FreeTDS driver on Windows](#freeTDS). Note that this is an evolving approach and Bill Evans notes some cons to using FreeTDS:
      + Might be slower than Microsoft drivers
      + `pool` package doesn't reconnect after disconnects
      + Hasn't been able to identify a way to use SSL for the database connections

## Debugging Step 2: Make it repeatable

This is a little more complex than the standard reprex because it requires
that you have access to a SQL Server database which has problematic data, and 
ideally that you can modify data in order to test theories.

### Create the test database 

[Simple steps based on instructions from Microsoft](https://docs.microsoft.com/en-us/sql/t-sql/statements/create-database-transact-sql?view=sql-server-ver15#a-creating-a-database-without-specifying-files).

```{r, warning=FALSE, message=FALSE}
library(tidyverse)

user_name <-
  keyring::key_list("dbi_test")$username

con <- DBI::dbConnect(
      odbc::odbc(),
      Driver = "SQL Server",
      Server = "testsqlserver",
      UID = user_name,
      PWD = keyring::key_get("dbi_test", user_name)
   )

# kill any connections before trying to drop database
DBI::dbExecute(con,
               "IF DB_ID (N'dbi_error') IS NOT NULL 
               ALTER DATABASE [dbi_error] set single_user
               with rollback immediate")

# Delete the test database if it already exists
DBI::dbExecute(con,
               "IF DB_ID (N'dbi_error') IS NOT NULL 
               DROP DATABASE dbi_error")

# Create the test database
DBI::dbExecute(con, "CREATE DATABASE dbi_error")

# Verify it was created
DBI::dbGetQuery(con,
                "SELECT name, size, size*1.0/128 AS [Size in MBs]
                FROM sys.master_files WHERE name = N'dbi_error'")

DBI::dbDisconnect(con)
```

### Write test data

Create working and non-working data: 

1. A table, "problem_data," with, "long" columns that are not the last columns in the table.
2. A table, "working_data," with the same data, only this time with the, "long," column at the end of the table.

```{r, warning=FALSE}
con <- DBI::dbConnect(
      odbc::odbc(),
      Driver = "SQL Server",
      Server = "testsqlserver",
      UID = user_name,
      Database = "dbi_error",
      PWD = keyring::key_get("dbi_test", user_name)
   )

dplyr::copy_to(con,
               tibble(a = 1:3, 
                      b = blob::blob(raw(1)), #blob data NOT at
                      # end of table
                      c = 1
                      ),
               "problem_data", # will expose problem
               temporary = FALSE
               )

dplyr::copy_to(con,
               tibble(a = 1:3,
                      c = 1,
                      b = blob::blob(raw(1)) # blob data at end
                      # of table
                      ),
               "working_data", # will not expose problem
               temporary = FALSE
               )
```

### Reproduce the error 
Here the problem occurs - because the column with, "long," data is NOT the the last column in the table.

```{r error=TRUE, warning=FALSE}
dplyr::tbl(con,"problem_data") %>% 
  collect()
```

Here the problem does not occur - because the column with "long" data is the last column in the table. 

```{r}
dplyr::tbl(con, "working_data") %>% 
  collect()
```

SOURCE: https://github.com/r-dbi/odbc/issues/309#issue-507726267 

## Debugging Step 3: Figure out where it is (the error)

```{r, error=TRUE, warning = FALSE}
dplyr::tbl(con,"problem_data") %>% 
  collect()
```
```{r}
traceback()
```

TODO: how am I going to display the output of traceback() from rmarkdown?

# Appendix: Some Reports of, and references to, this issue {#issues}

Issues logged against odbc R package:

* https://github.com/r-dbi/odbc/issues/10
* https://github.com/r-dbi/odbc/issues/86 
* https://github.com/r-dbi/odbc/issues/112 
* https://github.com/r-dbi/odbc/issues/256
* https://github.com/r-dbi/odbc/issues/309 
* https://github.com/r-dbi/odbc/issues/331
* https://github.com/r-dbi/odbc/issues/358

Pull request in odbc:

* [looks like it adds better error messaging (tremendously valuable!) vs. fully
addressing the problem](https://github.com/r-dbi/odbc/pull/359)

Issues logged against DBI R package:

* https://github.com/r-dbi/DBI/issues/315 

Issues logged against nanodbc:

* https://github.com/nanodbc/nanodbc/issues/149 
* https://github.com/nanodbc/nanodbc/issues/228 

[Most Helpful (to me) Stack Overflow thread](https://stackoverflow.com/questions/45001152/r-dbi-odbc-error-nanodbc-nanodbc-cpp3110-07009-microsoftodbc-driver-13-fo) 

# Appendix: Methods to move "long" data to end of query {#move_long_data}

## Method 1: Identify and move columns over a certain size to the end

```{r}
tbl_long_cols <- function(con, table, size_thresh = 200) {

    long_cols <-
        odbc::odbcConnectionColumns(con, table) %>%
        dplyr::filter(column_size >= size_thresh) %>%
        dplyr::pull(name)

    dplyr::tbl(con, table) %>%
        dplyr::select(-tidyselect::all_of(long_cols),
                      tidyselect::everything(),
                      tidyselect::all_of(long_cols))
}

tbl_long_cols(con,"problem_data") %>% 
  dplyr::collect()
```

## Method 2: sort by column size and move longest columns to end

This also demonstrates how you can re-order the, "long," columns freely after
the data has been retrieved from the database.

```{r}

tbl_long_cols_2 <- function(con, table) {
  cols_sorted <- 
    odbc::odbcConnectionColumns(con, table) %>% 
    dplyr::arrange(column_size) %>% 
    pull(name)

  dplyr::tbl(con, table) %>%
    dplyr::select(tidyselect::all_of(cols_sorted)) 
}

tbl_long_cols_2(con, "problem_data") %>% 
  dplyr::collect() %>% 
  dplyr::select(a,b,c) #can move the "long" cols back after retrievel from db
```

## Method 3: Move certain data types to the end

There are certain data types that are, "long." You can look for these long data
types and move them to the end of the select statement.


```{r}

tbl_long_cols_3 <- function(con, table) {
  long_cols <-
  odbc::odbcConnectionColumns(con, table) %>%
  dplyr::filter(field.type == "varbinary") %>%
  pull(name)

dplyr::tbl(con, table) %>%
  dplyr::select(-tidyselect::all_of(long_cols),
                tidyselect::everything(),
                tidyselect::all_of(long_cols))
}

tbl_long_cols_3(con, "problem_data") %>% 
  collect()
```

```{r close_connections, include = FALSE}
DBI::dbDisconnect(con)
```

# Appendix: Installing and using the FreeTDS driver on Windows {#freeTDS}

1. View the latest FreeTDS build for your architecture (32 or 64 bit). Here is a link to the current [FreeTDS build](https://ci.appveyor.com/project/FreeTDS/freetds) 

Click one of the rows.

![](/post/2020-05-13-error-invalid-descriptor-index_files/free_tds_1.png)

2. Click Artifacts and click a .zip file - I tried `vs2017_64-master.zip` variant but received an error when trying to register the driver dll. I *believe* this is due to the dependency on OpenSSL. I looked to install OpenSSL but it had quite a few dependencies that I didn't feel like setting up (Perl and make for example)

![](/post/2020-05-13-error-invalid-descriptor-index_files/free_tds_2.png)

3. Extract the contents of the zip file

4. Open a command prompt or PowerShell window and execute the following command:

`regsvr32 "C:\temp\vs2017_64-master\bin\tdsodbc.dll"`

5. Success should yield a message like this:

![](/post/2020-05-13-error-invalid-descriptor-index_files/freetds_install_success.png)


6. Verify that R can see the new driver

```{r}
odbc::odbcListDrivers() %>% 
  dplyr::filter(name == "FreeTDS")
```

Let's connect using the FreeTDS driver and verify the issue does not occur.

NOTE: I had to make a couple changes, in addition to changing the driver to get
this to work:

* Specified SQL port(typically this is 1433)
* Set the client character set to UTF-8 (referenced 
in [this post](https://lists.ibiblio.org/pipermail/freetds/2016q3/029980.html)).

```{r}
user_name <-
  keyring::key_list("dbi_test")$username

con_freetds <- DBI::dbConnect(
      odbc::odbc(),
      Driver = "FreeTDS",
      Server = "testsqlserver",
      UID = user_name,
      PWD = keyring::key_get("dbi_test", user_name),
      ClientCharset = "UTF-8",
      port = 1433,
      Database = "dbi_error"
   )

dplyr::tbl(con_freetds,"problem_data") %>% 
  collect()

DBI::dbDisconnect(con_freetds)
```

It works!

A few NOTES:

*  It's possible there may be an implication for extended (longer than 8-bit) 
character data when setting character set to 8-bit. I haven't evaluated that.

* I also tested FreeTDS in a Windows domain joined environment and it worked!

SOURCE: [Bill Even's GitHub Issue post where he shares solution](https://github.com/r-dbi/DBI/issues/315#issuecomment-639984938)

SOURCE: [Setting up FreeTDS to work with ODBC Data Source Administrator on Windows 7](https://lists.ibiblio.org/pipermail/freetds/2016q3/029980.html)

SOURCE: [FreeTDS user guide](https://www.freetds.org/userguide/osissues.html#Windows)

# Q&A

Q: How "long" data be identified?

A: 

> DBMSs define long data as any character or binary data over a certain size, such as 255 characters
TODO
SOURCE: [Microsoft documentation on Getting Long Data](https://docs.microsoft.com/en-us/sql/odbc/reference/develop-app/getting-long-data?view=sql-server-ver15)