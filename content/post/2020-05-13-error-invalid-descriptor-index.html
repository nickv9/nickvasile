---
title: 'Debugging the Invalid Descriptor Index Error' 
author: Nick Vasile
date: '2020-05-13'
slug: error-invalid-descriptor-index
categories: []
tags: []
---



<p><strong>This post is a work in progress</strong></p>
<div id="motivation" class="section level1">
<h1>Motivation</h1>
<p>I use the dbplyr, dplyr, DBI and odbc R packages to extract data held in Microsoft SQL on a daily basis.</p>
<p>I used to run into the, “Invalid Descriptor Index,” error documented <a href="https://github.com/r-dbi/odbc/issues/309">here</a> constantly. It was awful! I spent so much time trying to find the, “problem,” columns in tables that often had over 100 columns. The time I spent trying to get my queries to work severely reduced the time I had available to clean, transform and analyze my data.</p>
<p>Through the work of many great people sharing their expertise on GitHub, I was able to identify <a href="https://github.com/r-dbi/odbc/issues/309#issuecomment-615255613">a workaround that worked well for me</a>.</p>
<p>The workaround helped <em>me</em> continue my daily work but did nothing to <em>prevent</em> <em>others</em> from encountering the same issue in the future. One of the great things about R is the community and I would like to do my part to help. That might involve making a code change in a package or in another component involved.</p>
<p>I don’t yet have a firm grasp on what, from a technical standpoint, leads to the failure but I do know many things are involved - specifically multiple R packages, ODBC drivers and Microsoft SQL Server.</p>
<p>I am comfortable as an R user and debugging C++ code individually but have not spent much time debugging multi-component issues in R.</p>
<p>This investigation is an opportunity for me:</p>
<ul>
<li>Advance my R debugging skills so I well-armed to tackle other multi-component R issues in the future</li>
<li>Understand, at a deep level, the root cause, and contributing factors, of the failure that leads to this error. With that understanding I will be a much better position to propose, evaluate and contribute to solutions.</li>
</ul>
</div>
<div id="scope" class="section level1">
<h1>Scope</h1>
<p>I’ll be reproducing this issue using Microsoft SQL Server Express which is a free download available <a href="https://www.microsoft.com/en-us/sql-server/sql-server-downloads">here</a>.</p>
<p>I’ll be focusing my analysis on when this error occurs running R on the Microsoft Windows operating system.</p>
</div>
<div id="reproducing-the-problem" class="section level1">
<h1>Reproducing the problem</h1>
<p>First, I’ll create a test database following <a href="https://docs.microsoft.com/en-us/sql/t-sql/statements/create-database-transact-sql?view=sql-server-ver15#a-creating-a-database-without-specifying-files">simple steps based on instructions from Microsoft</a>.</p>
<pre class="r"><code>library(tidyverse)

user_name &lt;-
  keyring::key_list(&quot;dbi_test&quot;)$username

con &lt;- DBI::dbConnect(
      odbc::odbc(),
      Driver = &quot;SQL Server&quot;,
      Server = &quot;testsqlserver&quot;,
      UID = user_name,
      PWD = keyring::key_get(&quot;dbi_test&quot;, user_name)
   )

# kill any connections before trying to drop database
DBI::dbExecute(con,
               &quot;IF DB_ID (N&#39;dbi_error&#39;) IS NOT NULL 
               ALTER DATABASE [dbi_error] set single_user with rollback immediate&quot;)</code></pre>
<pre><code>## [1] 0</code></pre>
<pre class="r"><code># Delete the test database if it already exists
DBI::dbExecute(con,
               &quot;IF DB_ID (N&#39;dbi_error&#39;) IS NOT NULL 
               DROP DATABASE dbi_error&quot;)</code></pre>
<pre><code>## [1] 0</code></pre>
<pre class="r"><code># Create the test database
DBI::dbExecute(con, &quot;CREATE DATABASE dbi_error&quot;)</code></pre>
<pre><code>## [1] 0</code></pre>
<pre class="r"><code># Verify it was created
DBI::dbGetQuery(con,
                &quot;SELECT name, size, size*1.0/128 AS [Size in MBs]
                FROM sys.master_files WHERE name = N&#39;dbi_error&#39;&quot;)</code></pre>
<pre><code>##        name size Size in MBs
## 1 dbi_error 1024           8</code></pre>
<pre class="r"><code>DBI::dbDisconnect(con)</code></pre>
<p>Next, I’ll write two different sets of data:</p>
<ol style="list-style-type: decimal">
<li>A table, “problem_data,” with, “long” columns that are not the last columns in the table.</li>
<li>A table, “working_data,” with the same data, only this time with the, “long,” column at the end of the table.</li>
</ol>
<pre class="r"><code>con &lt;- DBI::dbConnect(
      odbc::odbc(),
      Driver = &quot;SQL Server&quot;,
      Server = &quot;testsqlserver&quot;,
      UID = user_name,
      Database = &quot;dbi_error&quot;,
      PWD = keyring::key_get(&quot;dbi_test&quot;, user_name)
   )

dplyr::copy_to(con,
               tibble(a = 1:3, 
                      b = blob::blob(raw(1)), #blob data NOT at end of table
                      c = 1
                      ),
               &quot;problem_data&quot;, # will expose problem
               temporary = FALSE
               )

dplyr::copy_to(con,
               tibble(a = 1:3,
                      c = 1,
                      b = blob::blob(raw(1)) # blob data at end of table
                      ),
               &quot;working_data&quot;, # will not expose problem
               temporary = FALSE
               )</code></pre>
<p>Here the problem occurs - because the column with, “long,” data is NOT the the last column in the table.</p>
<pre class="r"><code>dplyr::tbl(con,&quot;problem_data&quot;)</code></pre>
<pre><code>## Error in result_fetch(res@ptr, n): nanodbc/nanodbc.cpp:3186: 07009: [Microsoft][ODBC SQL Server Driver]Invalid Descriptor Index</code></pre>
<p>Here the problem does not occur - because the column with “long” data is the last column in the table.</p>
<pre class="r"><code>dplyr::tbl(con, &quot;working_data&quot;) %&gt;% 
  collect()</code></pre>
<pre><code>## # A tibble: 3 x 3
##       a     c         b
##   &lt;int&gt; &lt;dbl&gt;    &lt;blob&gt;
## 1     1     1 &lt;raw 1 B&gt;
## 2     2     1 &lt;raw 1 B&gt;
## 3     3     1 &lt;raw 1 B&gt;</code></pre>
<p>SOURCE: <a href="https://github.com/r-dbi/odbc/issues/309#issue-507726267" class="uri">https://github.com/r-dbi/odbc/issues/309#issue-507726267</a></p>
</div>
<div id="debugging-the-error" class="section level1">
<h1>Debugging the error</h1>
<p>One of the primary motivations for this post is to force me to advance my debugging skills.</p>
<p>I decided to start with <a href="https://adv-r.hadley.nz/debugging.html">the debugging chapter from Hadley Wickham’s Advanced R book</a>.</p>
<div id="debugging-step-1-google-it" class="section level2">
<h2>Debugging Step 1: Google it!</h2>
<p>I started out by Googling a portion of the error string, “<code>[Microsoft][ODBC SQL Server Driver]Invalid Descriptor Index</code>,” which yielded quite a few relevant hits, including a surprising amount of duplicate GitHub issues raised in the odbc project.</p>
<p>Based on Hadley’s recommendation in the book I decided to check out the <a href="https://github.com/r-assist/errorist">errorist package</a> which gave me much more target hits because it included the entire text of the error message in the search string. It was also automatic, saving me a second or two of copying and pasting. I’ll be incorporating this package into my debugging work-flow going forward!</p>
<p>I’ve captured a list of relevant issues, and the Stack Overflow thread I found most helpful in the <a href="#issues">Appendix</a>.</p>
<p>Here is what I gleaned:</p>
<ol style="list-style-type: decimal">
<li><p>Judging by the sheer frequency, and recency, of this issue being reported, I don’t believe this is a corner case affecting a small minority of R users.</p></li>
<li><p>This is caused by a ODBC (the Microsoft C interface - not the R odbc package) constraint:</p>
<ul>
<li>Called out as a limitation of <code>SQLGetData()</code> citing this portion of the documentation:</li>
</ul></li>
</ol>
<blockquote>
<p>There are several restrictions on using SQLGetData. Generally, columns accessed with SQLGetData:<br />
…<br />
Must have a higher column number than the last bound column. For example, if the last bound column is column 3, it is an error to call SQLGetData for column 2. For this reason, applications should make sure to place long data columns at the end of the select list.</p>
</blockquote>
<p>SOURCE: <a href="https://docs.microsoft.com/en-us/sql/odbc/reference/develop-app/getting-long-data?view=sql-server-ver15">Microsoft documentation on “Getting Long Data”</a></p>
<ol start="3" style="list-style-type: decimal">
<li><p>The most common workaround is to put “long” columns at the end of the select
statement, and there are a few different methods to do this.
See <a href="#move_long_data">Appendix: Methods to move “long” data to end of query</a> for
options to do this.</p></li>
<li><p>People have reported that the error doesn’t occur with:</p>
<ul>
<li>RStudio’s professional drivers which are part of their commercial
(you need to pay for) offerings. SOURCE: <a href="https://github.com/r-dbi/odbc/issues/86#issuecomment-558280484">GitHub issue comment from Jim Hester</a></li>
<li>RODBC package.
<a href="https://github.com/r-dbi/odbc/issues/256#issue-411385255">Reported in this GitHub issue</a>,
although Jim Hester reported <a href="https://github.com/r-dbi/odbc/issues/86#issuecomment-558199954">here</a>
that RODBC is simply truncating the long data.</li>
<li>FreeTDS drivers SOURCE: <a href="https://github.com/r-dbi/DBI/issues/315#issuecomment-639984938">Bill Evans comment on GitHub</a> See <a href="#freeTDS">Appendix: Installing and using the FreeTDS driver on Windows</a>. Note that this is an evolving approach and Bill Evans notes some cons to using FreeTDS:
<ul>
<li>Might be slower than Microsoft drivers</li>
<li><code>pool</code> package doesn’t reconnect after disconnects</li>
<li>Hasn’t been able to identify a way to use SSL for the database connections</li>
</ul></li>
</ul></li>
</ol>
</div>
</div>
<div id="issues" class="section level1">
<h1>Appendix: Some Reports of, and references to, this issue</h1>
<p>Issues logged against odbc R package:</p>
<ul>
<li><a href="https://github.com/r-dbi/odbc/issues/10" class="uri">https://github.com/r-dbi/odbc/issues/10</a></li>
<li><a href="https://github.com/r-dbi/odbc/issues/86" class="uri">https://github.com/r-dbi/odbc/issues/86</a></li>
<li><a href="https://github.com/r-dbi/odbc/issues/112" class="uri">https://github.com/r-dbi/odbc/issues/112</a></li>
<li><a href="https://github.com/r-dbi/odbc/issues/256" class="uri">https://github.com/r-dbi/odbc/issues/256</a></li>
<li><a href="https://github.com/r-dbi/odbc/issues/309" class="uri">https://github.com/r-dbi/odbc/issues/309</a></li>
<li><a href="https://github.com/r-dbi/odbc/issues/331" class="uri">https://github.com/r-dbi/odbc/issues/331</a></li>
<li><a href="https://github.com/r-dbi/odbc/issues/358" class="uri">https://github.com/r-dbi/odbc/issues/358</a></li>
</ul>
<p>Pull request in odbc:</p>
<ul>
<li><a href="https://github.com/r-dbi/odbc/pull/359" class="uri">https://github.com/r-dbi/odbc/pull/359</a> &lt;- looks like it adds better error messaging (tremendously valuable!) vs. fully addressing the problem</li>
</ul>
<p>Issues logged against DBI R package:</p>
<ul>
<li><a href="https://github.com/r-dbi/DBI/issues/315" class="uri">https://github.com/r-dbi/DBI/issues/315</a></li>
</ul>
<p>Issues logged against nanodbc:</p>
<ul>
<li><a href="https://github.com/nanodbc/nanodbc/issues/149" class="uri">https://github.com/nanodbc/nanodbc/issues/149</a></li>
<li><a href="https://github.com/nanodbc/nanodbc/issues/228" class="uri">https://github.com/nanodbc/nanodbc/issues/228</a></li>
</ul>
<p>Most Helpful (to me) Stack Overflow thread:</p>
<ul>
<li><a href="https://stackoverflow.com/questions/45001152/r-dbi-odbc-error-nanodbc-nanodbc-cpp3110-07009-microsoftodbc-driver-13-fo" class="uri">https://stackoverflow.com/questions/45001152/r-dbi-odbc-error-nanodbc-nanodbc-cpp3110-07009-microsoftodbc-driver-13-fo</a></li>
</ul>
</div>
<div id="move_long_data" class="section level1">
<h1>Appendix: Methods to move “long” data to end of query</h1>
<div id="method-1-identify-and-move-columns-over-a-certain-size-to-the-end" class="section level2">
<h2>Method 1: Identify and move columns over a certain size to the end</h2>
<pre class="r"><code>tbl_long_cols &lt;- function(con, table, size_thresh = 200) {

    long_cols &lt;-
        odbc::odbcConnectionColumns(con, table) %&gt;%
        dplyr::filter(column_size &gt;= size_thresh) %&gt;%
        dplyr::pull(name)

    dplyr::tbl(con, table) %&gt;%
        dplyr::select(-tidyselect::all_of(long_cols),
                      tidyselect::everything(),
                      tidyselect::all_of(long_cols))
}

tbl_long_cols(con,&quot;problem_data&quot;) %&gt;% 
  dplyr::collect()</code></pre>
<pre><code>## # A tibble: 3 x 3
##       a     c         b
##   &lt;int&gt; &lt;dbl&gt;    &lt;blob&gt;
## 1     1     1 &lt;raw 1 B&gt;
## 2     2     1 &lt;raw 1 B&gt;
## 3     3     1 &lt;raw 1 B&gt;</code></pre>
</div>
<div id="method-2-sort-by-column-size-and-move-longest-columns-to-end" class="section level2">
<h2>Method 2: sort by column size and move longest columns to end</h2>
<p>This also demonstrates how you can re-order the, “long,” columns freely after
the data has been retrieved from the database.</p>
<pre class="r"><code>tbl_long_cols_2 &lt;- function(con, table) {
  cols_sorted &lt;- 
    odbc::odbcConnectionColumns(con, table) %&gt;% 
    dplyr::arrange(column_size) %&gt;% 
    pull(name)

  dplyr::tbl(con, table) %&gt;%
    dplyr::select(tidyselect::all_of(cols_sorted)) 
}

tbl_long_cols_2(con, &quot;problem_data&quot;) %&gt;% 
  dplyr::collect() %&gt;% 
  dplyr::select(a,b,c) #can move the &quot;long&quot; cols back after retrievel from db</code></pre>
<pre><code>## # A tibble: 3 x 3
##       a         b     c
##   &lt;int&gt;    &lt;blob&gt; &lt;dbl&gt;
## 1     1 &lt;raw 1 B&gt;     1
## 2     2 &lt;raw 1 B&gt;     1
## 3     3 &lt;raw 1 B&gt;     1</code></pre>
</div>
<div id="method-3-move-certain-data-types-to-the-end" class="section level2">
<h2>Method 3: Move certain data types to the end</h2>
<p>There are certain data types that are, “long.” You can look for these long data
types and move them to the end of the select statement.</p>
<pre class="r"><code>tbl_long_cols_3 &lt;- function(con, table) {
  long_cols &lt;-
  odbc::odbcConnectionColumns(con, table) %&gt;%
  dplyr::filter(field.type == &quot;varbinary&quot;) %&gt;%
  pull(name)

dplyr::tbl(con, table) %&gt;%
  dplyr::select(-tidyselect::all_of(long_cols),
                tidyselect::everything(),
                tidyselect::all_of(long_cols))
  
}

tbl_long_cols_3(con, &quot;problem_data&quot;) %&gt;% 
  collect()</code></pre>
<pre><code>## # A tibble: 3 x 3
##       a     c         b
##   &lt;int&gt; &lt;dbl&gt;    &lt;blob&gt;
## 1     1     1 &lt;raw 1 B&gt;
## 2     2     1 &lt;raw 1 B&gt;
## 3     3     1 &lt;raw 1 B&gt;</code></pre>
</div>
</div>
<div id="freeTDS" class="section level1">
<h1>Appendix: Installing and using the FreeTDS driver on Windows</h1>
<ol style="list-style-type: decimal">
<li>View the latest FreeTDS build for your architecture (32 or 64 bit). Here is a link to the current <a href="https://ci.appveyor.com/project/FreeTDS/freetds">FreeTDS build</a></li>
</ol>
<p>Click one of the rows.</p>
<p><img src="/post/2020-05-13-error-invalid-descriptor-index_files/free_tds_1.png" /></p>
<ol start="2" style="list-style-type: decimal">
<li>Click Artifacts and click a .zip file</li>
</ol>
<p><img src="/post/2020-05-13-error-invalid-descriptor-index_files/free_tds_2.png" /></p>
<ol start="3" style="list-style-type: decimal">
<li>Extract the contents of the zip file</li>
</ol>
<p>SOURCE: <a href="https://github.com/r-dbi/DBI/issues/315#issuecomment-639984938">Bill Even’s GitHub Issue post where he shares solution</a></p>
<p>SOURCE: <a href="https://lists.ibiblio.org/pipermail/freetds/2016q3/029980.html">Setting up FreeTDS to work with ODBC Data Source Administrator on Windows 7</a></p>
</div>
<div id="qa" class="section level1">
<h1>Q&amp;A</h1>
<p>Q: How “long” data be identified?</p>
<p>A:</p>
<blockquote>
<p>DBMSs define long data as any character or binary data over a certain size, such as 255 characters
TODO
SOURCE: <a href="https://docs.microsoft.com/en-us/sql/odbc/reference/develop-app/getting-long-data?view=sql-server-ver15">Microsoft documentation on Getting Long Data</a></p>
</blockquote>
</div>
